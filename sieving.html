<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-124058257-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-124058257-1');
    </script>
    <meta charset="utf-8">
    <title>Eratothenses sieve</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Spencer Greene's personal website">
    <style>
      p {
        font-size: 16px;
        font-family: "verdana";
      }
      h1 {
        font-family: "verdana";
      }
    </style>
  </head>
  <body>
    <h1>
      Finding prime numbers
    </h1>
    <p>
      Generating all prime numbers below a given number<br>
      is an interesting problem. There are several ways<br>
      to do it. I was curious about how some of the<br>
      algorithms stack up against each other.
    </p>
    <p>
      Here is a program written in Python3 that returns a<br>
      list of prime numbers below a limit. It uses trial<br>
      division on every integer below the given limit.<br>
    </p>
    <script src="https://gist.github.com/spwg/c7dcf72b27a4bdcf74f67c776d45ccdb.js"></script>
    <p>
      Another way to get all prime numbers below a number<br>
      is to use a sieve. The Sieve of Eratothenses is<br>
      apparently the easiest one to implement. It starts<br>
      at 2 and leverages the fact that it's prime to<br>
      start off a computation. To start, we assume everything<br>
      between 2 and the limit is prime. Then, we mark<br>
      every multiple of 2 as not prime, then every multiple<br>
      of 2 and 3, then 2, 3, 5, and so on...
    </p>
    <script src="https://gist.github.com/spwg/6c15575c6f391fcec3eb03339ce59d1c.js"></script>
    <p>
      This is pretty much a direct implementation<br>
      of the pseudocode on Wikipedia.<br>
    </p>
    <p>
      The Sieve of Eratothenses runs out of memory when<br>
      the limit is so big that allocating an array to track<br>
      all the integers below the limit doesn't fit into<br>
      RAM. On my machine, a 2017 MBP with 16 GB of RAM<br>
      and a 2.8 GHz Intel Core i7 processor that number is<br>
      9,223,372,036,854,775,807, or nine quintillion two<br>
      hundred twenty three quadrillion three hundred seventy<br>
      two trillion thirty six billion eight hundred fifty<br>
      four million seven hundred seventy five thousand eight<br>
      hundred seven.
    </p>
    <p>
      Note that the multiplication of two large primes used<br>
      for RSA encryption is over 300 digits long.
    </p>
    <p>
      A Segmented Sieve gets around this issue by kickstarting<br>
      some fraction of the computation with another prime<br>
      finder, such as the Sieve of Eratothenses. Then, it<br>
      segements the rest of the computation into chunks<br>
      so that we never allocate an array that doesn't fit<br>
      in memory.
    </p>
    <script src="https://gist.github.com/spwg/50e6915ad01b5d1530e3f22ac044b395.js"></script>
    <p>
      Here are some nice graphs that show the growth in time<br>
      (in seconds) as a function of the limit we want primes<br>
      below.
    </p>
    <div>
      <image src='/assets/SegmentedSieve.png' />
    </div>
    <div>
      <image src='/assets/SieveOfEratothenses.png' />
    </div>
    <div>
      <image src='/assets/TrialDivision.png' />
    </div>
    <style>
      .gist{font-size:16px;width:43em}
    </style>
    <p>
      These graphs show, among other things, how time<br>
      complexity can be misleading if you don't profile<br>
      your code. The Sieve of Eratothenses<br>
      is much faster than the Segmented Sieve despite their<br>
      shared time complexity of O(n -> n * log(log(n))).
    </p>
    <p>
      For more:
      <a href='https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes'>https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes.</a>
    </p>
  </body>
</html>
